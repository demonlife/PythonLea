* Basic Python
** 判断
   if x: pass
   只要x是非零数值、非空字符串、非空list, 非None， 非空dict等，就判断为True，否则为False
** set
   set的初始化:
   s = set() #空set
   s = set([1, 2, 3, 3]) #set必须使用list来初始化, 并且set会除去重复的元素
   set的原理和dict一样, 不能放入可变对象
   参看如下的实例:
   s = set([[1, 2], 3, 4]) # error
   s = set([(1, 2), 3, 4]) # right
   set可以做集合运算, list不可以
   s1 & s2 #交集
   s1 | s2 #并集
   ...
** 不变对象
   对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容
** 函数
   完全可以把一个函数名赋值给一个变量,  相当于给这个函数起了一个"别名"
   a = abs
   a(-1) #=> 1
   python中对匿名函数提供了有限的支持, 就是只能有一个表达式, 不用写return, 返回值就是该表达式的结果
*** functools
    偏函数
    import functools
    int2 = functools.partial(int, base=2)
    int2('10000')
    functools.partial的作用就是，把一个函数的某些参数（不管有没有默认值）给固定住（也就是设置默认值），
    返回一个新的函数，调用这个新函数会更简单
    创建偏函数时，要从右到左固定参数
*** 默认参数
    定义默认参数必须指向不变的对象, 否则会出现一些很奇怪的问题
    对于任何函数, 通过类似func(*args, **kw)的形式调用它，不管它的参数是如何定义的
*** 递归调用
    解决递归调用栈溢出的方法是通过尾递归优化。
    尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。
    这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，
    不会出现栈溢出的情况
    尾调用的定义: http://zh.wikipedia.org/zh-cn/%E5%B0%BE%E8%B0%83%E7%94%A8
    但是python没有对尾递归做优化, 一个针对尾递归优化的decorator,参考源码:
    http://code.activestate.com/recipes/474088-tail-call-optimization-decorator/

    针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，
    没有循环语句的编程语言只能通过尾递归实现循环
** for
   当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，
   而我们不太关心该对象究竟是list还是其他数据类型
   判断一个对象是否是可迭代对象:
   from collections import Iterable
   isinstance('abc', Iterable) #=> True, 可迭代对象, False不可迭代对象

   enumerate可以将list变成索引-元素对
   for i, v in enumrate([1, 2, 3]):
       print i, v
** 生成器
   创建生成器的方法
   1. 将一个列表生成式稍作变化即可,
      g = (s for s in xrange(11))
   2. 将一个函数变成生成器
      只需将return换成yield即可
      变成generator的函数，
       在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行
** 模块搜索路径
   import sys
   sys.path #=> 输出模块的加载路径
*** 添加修改路径
    1. 修改sys.path
       sys.path.append('/loadpath')
    2. 设置PYTHONPATH
** 使用__future__
   把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性
   例如:
   from __future__ import unicode_literals
   print isinstance('xxx', unicode) #=> True

   from __future__ import division
   10 / 3 #=> 3.3333
** 对象
   获取对象信息
   type(xx)
   python将每种type类型都定义好了常量, 放在types模块里, 使用之前, 导入即可
   import types
   if type('abc') == types.StringType: xx
   注意有一种类型就叫TypeType，所有类型本身的类型就是TypeType, 如:
   type(int) == type(str) == types.TypeType

   能用type()判断的基本类型也可以用isinstance()判断
   isinstance()还可以判断一个变量是否是某些类型中的一种
   isinstance('a', (str, unicode))
   利用hasattr(), getattr(), setattr()可以操作一个对象的状态
   如果在使用getattr()获取不存在的属性时, 会报错, 可以设定一个默认值
   getattr(obj, 'z', 404) #属性z不存在, 就返回404
   getattr() 也可以获取对象的方法
*** __slots__   
    想限制类的属性, 就需要用到__slots__变量
    __slots__定义的属性仅对当前类起作用，对继承的子类是不起作用的
    除非在子类中也定义__slots__,这样,子类允许定义的属性就是自身的__slots__加上父类的__slots__

    如果父类没有定义__slots__, 则子类定义的__slots__的不起作用
    一个使用__slots__减少内存占用的案例：http://blog.jobbole.com/52420/
    默认情况下，Python用一个dict来存储对象实例的属性。这在一般情况下还不错，而且非常灵活，
    乃至你在运行时可以随意设置新的属性。但是，对一些在”编译”前就知道该有几个固定属性的小class来说，
    这个dict就有点浪费内存了。
    还可以用collections.namedtuple，它允许访问参数，但只占用一个tuple的空间。
*** 对类的所有属性和方法调用全部动态化, __getattr__
    只有在没有找到属性的情况下, 才调用__getattr__, 已有的属性, 不会在__getattr__
    中查找, 利用该方法可以动态的调用
    class Chain(object):
        def __init__(self, path=''):
            self._path = path

        def __getattr__(self, path):
            return Chain('%s/%s' % (self._path, path))

        def __str__(self):
            return self._path
    具体使用参看codesegment/objecttypes.py
*** 可调用
    通过callable(), 可以判断出一个对象是否是"可调用"对象
    任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用
*** Mixin
    如果需要“混入”额外的功能，通过多重继承就可以实现，
    比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为Mixin。
    为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixin和FlyableMixin。
    类似的，你还可以定义出肉食动物CarnivorousMixin和植食动物HerbivoresMixin，
    让某个动物同时拥有好几个Mixin
    
    class Dog(Mammal, RunnableMixin, CarnivorousMixin):
        pass
*** 定制类
    通过实现类的特定方法, 如__str__, __len__等等方法
    __str__: 将类返回一个好看的格式
    __iter__: 类可以迭代, 此时还要定义next方法
    __getitem__: 类可以当做list来取数据, 此时入股传入的是一个slice, 需要对slice做特殊处理
    例如:
    class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int):
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice):
            start = n.start
            stop = n.stop
            a, b = 1, 1
            L = []
            for x in range(stop + 1):
                if x >= start:
                    L.append(a)
                a, b = b, a + b
            return L
    __call__: 可以直接对实例进行调用,__call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样
*** 使用type创建类    
    type()函数既可以返回一个对象的类型，又可以创建出新的类型
    参考codesegment/objecttypes.py
*** metaclass
    控制类的创建行为，还可以使用metaclass
    即:先定义metaclass，就可以创建类，最后创建实例
    参见 codesegment/metaclass.py
    一个理解元类的网址: http://blog.jobbole.com/21351/
*** 类属性与实例属性
    直接在类中定义的属性就是类属性
    通过self.xx = xx的属性是实例属性
    在编写程序的时候，千万不要把实例属性和类属性使用相同的名字
** 错误处理
   常见的错误类型和继承关系:https://docs.python.org/2/library/exceptions.html#exception-hierarchy
*** 调试
    可以使用断言,assert. 启动python的时候可以使用-O参数来关闭assert
    使用logging
**** 使用pdb
     python -m pdb filename.py
     pdb定位到下一步要执行的代码 -> s = '0'。输入命令l来查看代码
     n单步执行
     p xx: 打印xx的值, xx可以是python合法的语句
     一步一步调试很费劲, 可以在源代码中使用如下方法来快速定位:
     import pdb
     在需要调试的代码前: pdb.set_trace()
     之后运行程序(python filename.py), 程序会自动在此处暂停并进入pdb调试环境
** 正则表达式
***    
** 数据结构       
   http://blog.jobbole.com/65218/
*** collections
    collections模块包含了内建类型之外的一些有用的工具，
    例如Counter、defaultdict、OrderedDict、deque以及nametuple。
    其中Counter、deque以及defaultdict是最常用的类
**** deque
    deque是一种由队列结构扩展而来的双端队列(double-ended queue)，队列元素能够在队列两端添加或删除。
    因此它还被称为头尾连接列表(head-tail linked list)，尽管叫这个名字的还有另一个特殊的数据结构实现

    Deque支持线程安全的，经过优化的append和pop操作，在队列两端的相关操作都能够达到近乎O(1)的时间复杂度。
**** defaultdict
    这个类型除了在处理不存在的键的操作之外与普通的字典完全相同。
    当查找一个不存在的键操作发生时，它的default_factory会被调用，提供一个默认的值，
    并且将这对键值存储下来。其他的参数同普通的字典方法dict()一致，
    一个defaultdict的实例同内建dict一样拥有同样地操作。
*** array
    array模块定义了一个很像list的新对象类型，
    不同之处在于它限定了这个类型只能装一种类型的元素。array元素的类型是在创建并使用的时候确定的。

    如果你的程序需要优化内存的使用，并且你确定你希望在list中存储的数据都是同样类型的，
    那么使用array模块很合适。虽然说能够节省空间，array上几乎没有什么基本操作能够比在list上更快。

    在使用array进行计算的时候，需要特别注意那些创建list的操作。例如，使用列表推导式(list comprehension)的时候，
    会将array整个转换为list，使得存储空间膨胀。一个可行的替代方案是使用生成器表达式创建新的array。看代码：
    import array
    
    a = array.array("i", [1,2,3,4,5])
    b = array.array(a.typecode, (2*x for x in a))
    因为使用array是为了节省空间，所以更倾向于使用in-place操作。一种更高效的方法是使用enumerate：
    import array
    a = array.array("i", [1,2,3,4,5])
    for i, x in enumerate(a):
    a[i] = 2*x
    对于较大的array，这种in-place修改能够比用生成器创建一个新的array至少提升15%的速度。

    那么什么时候使用array呢？是当你在考虑计算的因素之外，
    还需要得到一个像C语言里一样统一元素类型的数组时。
    import array
    from timeit import Timer
    
    def arraytest():
        a = array.array("i", [1, 2, 3, 4, 5])
        b = array.array(a.typecode, (2 * x for x in a))
 
    def enumeratetest():
        a = array.array("i", [1, 2, 3, 4, 5])

    for i, x in enumerate(a):
        a[i] = 2 * x
 
    if __name__=='__main__':
        m = Timer("arraytest()", "from __main__ import arraytest")
        n = Timer("enumeratetest()", "from __main__ import enumeratetest")
 
        print m.timeit() # 5.22479210582
        print n.timeit() # 4.34367196717
*** heapq
    heapq模块使用一个用堆实现的优先级队列。堆是一种简单的有序列表，并且置入了堆的相关规则

    import heapq
    heap = []
 
    for value in [20, 10, 30, 50, 40]:
        heapq.heappush(heap, value)
 
    while heap:
        print heapq.heappop(heap)

    heapq有两个函数nlargest()和smallest()，两个函数也能够通过一个键参数使用复杂的数据结构
    portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
    ]

    cheap = heapq.nsmallest(3, portfolio, key = lambda s: s['price'])
    expensive = heapq.nlargest(3, portfolio, key = lambda s: s['price'])
        
    import heapq
    class Item:
        def __init__(self, name):
            self.name = name
 
        def __repr__(self):
            return 'Item({!r})'.format(self.name)
 
    class PriorityQueue:
        def __init__(self):
            self._queue = []
            self._index = 0
     
        def push(self, item, priority):
            heapq.heappush(self._queue, (-priority, self._index, item))
            self._index += 1
     
        def pop(self):
            return heapq.heappop(self._queue)[-1]
     
    q = PriorityQueue()
    q.push(Item('foo'), 1)
    q.push(Item('bar'), 5)
    q.push(Item('spam'), 4)
    q.push(Item('grok'), 1)
     
    print q.pop() # Item('bar')
    print q.pop() # Item('spam')
    print q.pop() # Item('foo')
    print q.pop() # Item('grok')
*** bisect
    bisect模块能够提供保持list元素序列的支持。它使用了二分法完成大部分的工作。
    它在向一个list插入元素的同时维持list是有序的。在某些情况下，这比重复的对一个list进行排序更为高效，
    并且对于一个较大的list来说，对每步操作维持其有序也比对其排序要高效。
*** weakref
    weakref模块能够帮助我们创建Python引用，却不会阻止对象的销毁操作。
    这一节包含了weak reference的基本用法，并且引入一个代理类。
    
    strong reference是一个对对象的引用次数、生命周期以及销毁时机产生影响的指针。
    strong reference如你所见，就是当你将一个对象赋值给一个变量的时候产生的：
    
    a = [1,2,3]
    b = a
    在这种情况下，这个列表有两个strong reference，分别是a和b。
    在这两个引用都被释放之前，这个list不会被销毁

    Weak reference则是对对象的引用计数器不会产生影响。当一个对象存在weak reference时，
    并不会影响对象的撤销。这就说，如果一个对象仅剩下weak reference，那么它将会被销毁。 

    你可以使用weakref.ref函数来创建对象的weak reference。
    这个函数调用需要将一个strong reference作为第一个参数传给函数，并且返回一个weak reference。
    例如：
    import weakref

    a = Foo()
    b = weakref.ref(a)

    一个临时的strong reference可以从weak reference中创建，即下例中的b()：
    a == b() 
    如果通过weakref来访问，需要使用如下方式：b().show() <==> a.show()
    当我们删除strong reference的时候，对象将立即被销毁

    使用weakref.proxy，就能提供相对于weakref.ref更透明的可选操作。
    同样是使用一个strong reference作为第一个参数并且返回一个weak reference，
    proxy更像是一个strong reference，但当对象不存在时会抛出异常。
    a = Foo()
    b = weakref.proxy(a)
    b.show() <==> a.show()

    最好将weak reference用于开销较大的对象，或避免循环引用(虽然垃圾回收器经常干这种事情)

    提示：只有library模块中定义的class instances、functions、methods、sets、frozen sets、
    files、generators、type objects和certain object types
    (例如sockets、arrays和regular expression patterns)支持weakref。
    内建函数以及大部分内建类型如lists、dictionaries、strings和numbers则不支持。
*** copy
    通过shallow或deep copy语法提供复制对象的函数操作
    对于shallow copy而言，它创建一个新的混合对象，并且将原对象中其他对象的引用插入新对象
    对于deep copy而言，它创建一个新的对象，并且递归地复制源对象中的其他对象并插入新的对象中
    普通的赋值操作只是简单的将新变量指向源对象
    
*** pprint
    pprint模块能够提供比较优雅的数据结构打印方式，如果你需要打印一个结构较为复杂，
    层次较深的字典或是JSON对象时，使用Pprint能够提供较好的打印结果
    
* python 技巧
** 一行代码定义一颗树
   def tree(): return defaultdict(tree)
** json
   import json
   json.dumps(mydict, ensure_ascii=False, indent=2) #输出中文，并且带有2个缩进
